        - function calculateSplitValue(a::DifferenceSplit,fname::Symbol,number_of_num_features::Int,labellist::Array{UInt8,1},sumnumerator::Array{Float64,1},sumdenominator::Array{Float64,1},sumweight::Array{Float64,1},countlistfloat::Array{Float64,1},minweight::Float64,subs::DTSubsets)
        - #here randomweight==0
        - #for subsets, exhaustive search with flipping members (gray code) or "increasing" subset search ({1}, {1,2}, {1,2,3}, .... {1,2,3, ....., n-1,2})
        - #all input lists (labellist,sumnumerator,sumdenominator,sumweight,countlistfloat) need to be sorted in the same manner
        - #convention, in the beginning everything is on the right side
  1747200 elementsInLeftChildBV=BitVector(length(labellist));fill!(elementsInLeftChildBV,false) #indicates which classes belong to right child
  1390480 chosen_subset_bitarray=similar(elementsInLeftChildBV) #BitVector(0)
        0 numtot=sum(sumnumerator)
        0 denomtot=sum(sumdenominator)
        0 weighttot=sum(sumweight)
        0 weighttot_minw=weighttot-minweight
        - 
        0 sumnl=sumdl=sumwl=0.0
        0 val=-Inf
        0 chosen_sumwl=NaN
        0   for i in subs
        -   #@show "vv=$(i)" #should be the element which switches
        -   #i is an index, it indicates which element of labellist will flip sides for the next calculation
        0   if elementsInLeftChildBV[i]
        -   #update elementsInLeftChildBV, i.e. toggle the value of the ith component, $=XOR
        0   elementsInLeftChildBV[i]=xor(elementsInLeftChildBV[i],true) #updating needs to occur here before we copy the array (in case it is a better split than what we have seen so far)
        -     #move class from left to right side
        0     sumnl-=sumnumerator[i]
        0 	sumdl-=sumdenominator[i]
        0 	sumwl-=sumweight[i]    
        -   else
        -   #update elementsInLeftChildBV, i.e. toggle the value of the ith component, $=XOR
        0   elementsInLeftChildBV[i]=xor(elementsInLeftChildBV[i],true)
        -       #move class from right to left side    
        0     sumnl+=sumnumerator[i]
        0 	sumdl+=sumdenominator[i]
        0 	sumwl+=sumweight[i]    	
        -   end
        0     if (sumwl>minweight)&&(weighttot_minw>sumwl) #do we have enough exposure? is the split valid?
        - 	  #vold=valnew
        0 	  valnew=abs(sumnl/sumdl-(numtot-sumnl)/(denomtot-sumdl))	  
        -       #if vold==valnew;@show i,valnew,sumnl,sumdl;end;
        0 	  if valnew>val
        0         val=valnew
        -         #chosen_subset_bitarray=copy(elementsInLeftChildBV)        
        0         chosen_subset_bitarray.=elementsInLeftChildBV
        0         chosen_sumwl=sumwl
        -       end
        -     end
        - end
        0 if isfinite(val)
        -   #warning: if the labellist is not sorted 1:n we need to be careful here!
        0   chosen_subset=labellist[chosen_subset_bitarray]
        - else
   193840   chosen_subset=Array{UInt}(0)
        - end
   917280 return val,chosen_subset,chosen_sumwl,weighttot-chosen_sumwl
        - end
        - 
        - 
        - function calculateSplitValue(a::DifferenceSplit,fname::Symbol,number_of_num_features::Int,labellist::Array{UInt8,1},sumnumerator::Array{Float64,1},sumdenominator::Array{Float64,1},sumweight::Array{Float64,1},countlistfloat::Array{Float64,1},minweight::Float64,subs::DTSubsets,feature_column_id::Int64)
        - #here randomweight>0
        - #for subsets, exhaustive search with flipping members (gray code) or "increasing" subset search ({1}, {1,2}, {1,2,3}, .... {1,2,3, ....., n-1,2})
        - #all input lists (labellist,sumnumerator,sumdenominator,sumweight,countlistfloat) need to be sorted in the same manner
        - #convention, in the beginning everything is on the right side
        - elementsInLeftChildBV=BitVector(length(labellist));fill!(elementsInLeftChildBV,false) #indicates which classes belong to right child
        - numtot=sum(sumnumerator)
        - denomtot=sum(sumdenominator)
        - weighttot=sum(sumweight)
        - weighttot_minw=weighttot-minweight
        - sumnl=sumdl=sumwl=0.0
        - this_splitlist=Array{Splitdef}(0)
        - 
        - for i in subs
        -     #i is an index, it indicates which element of labellist will flip sides for the next calculation
        -  if elementsInLeftChildBV[i]
        -   #update elementsInLeftChildBV, i.e. toggle the value of the ith component, $=XOR
        -   elementsInLeftChildBV[i]=xor(elementsInLeftChildBV[i],true) #updating needs to occur here before we copy the array (in case it is a better split than what we have seen so far)
        -     #move class from left to right side
        -     sumnl-=sumnumerator[i]
        - 	sumdl-=sumdenominator[i]
        - 	sumwl-=sumweight[i]  
        -   else
        -   #update elementsInLeftChildBV, i.e. toggle the value of the ith component, $=XOR
        -   elementsInLeftChildBV[i]=xor(elementsInLeftChildBV[i],true)
        -       #move class from right to left side    
        -     sumnl+=sumnumerator[i]
        - 	sumdl+=sumdenominator[i]
        - 	sumwl+=sumweight[i]
        -   end
        -     if (sumwl>minweight)&&(weighttot_minw>sumwl) #do we have enough exposure? is the split valid?
        -       valnew=abs(sumnl/sumdl-(numtot-sumnl)/(denomtot-sumdl))	  
        -       feature_column_id2 = feature_column_id < 0 ? abs(feature_column_id)+number_of_num_features : feature_column_id
        - 	  push!(this_splitlist,Splitdef(feature_column_id,feature_column_id2,fname,labellist[elementsInLeftChildBV],valnew,sumwl,weighttot-sumwl))
        -     end
        - end
        - return this_splitlist
        - end
        - 
        - 
